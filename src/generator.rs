use super::Snowflake;

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
/// A snowflake generator that can be used to generate snowflake IDs.
pub struct SnowflakeGenerator {
    /// The last snowflake ID generated by the generator.
    pub last_snowflake: Snowflake,
}

impl SnowflakeGenerator {
    /// Create a new snowflake generator with the given worker ID
    ///
    /// # Arguments
    /// * `worker_id` - The worker ID of the snowflake generator
    ///
    /// # Returns
    /// A new `SnowflakeGenerator`
    ///
    /// # Example
    /// ```rust
    /// use rusty_snowflake::{SnowflakeGenerator, Snowflake};
    ///
    /// const WORKER_ID: u64 = 420;
    ///
    /// let generator = SnowflakeGenerator::new(WORKER_ID);
    ///
    /// assert_eq!(generator.last_snowflake, Snowflake::new(WORKER_ID));
    /// ```
    pub fn new(worker_id: u64) -> SnowflakeGenerator {
        SnowflakeGenerator {
            last_snowflake: Snowflake::new(worker_id),
        }
    }

    /// Start at the given snowflake
    ///
    /// # Arguments
    /// * `snowflake` - The snowflake to start at
    ///
    /// # Returns
    /// A `SnowflakeGenerator`
    ///
    /// # Example
    /// ```rust
    /// use rusty_snowflake::{Snowflake, SnowflakeGenerator};
    ///
    /// const WORKER_ID: u64 = 420;
    ///
    /// let generator = SnowflakeGenerator::start_at(&Snowflake::new(WORKER_ID));
    ///
    /// assert_eq!(generator.last_snowflake, Snowflake::new(WORKER_ID));
    /// ```
    pub fn start_at(snowflake: &Snowflake) -> SnowflakeGenerator {
        SnowflakeGenerator {
            last_snowflake: *snowflake,
        }
    }

    /// Generates the next snowflake ID and returns a reference to it.
    ///
    /// This method generates the next snowflake ID by updating the `last_snowflake` stored in the generator.
    /// It increments the sequence number and, if necessary, adjusts the timestamp to ensure uniqueness.
    /// The generated snowflake ID is then returned as a reference.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use rusty_snowflake::SnowflakeGenerator;
    ///
    /// let mut generator = SnowflakeGenerator::new(420);
    ///
    /// // Generate the next snowflake ID
    /// let snowflake = generator.next();
    /// println!("Generated snowflake ID: {:?}", snowflake);
    /// ```
    ///
    /// # Returns
    ///
    /// A reference to the generated snowflake ID.
    ///
    /// # Panics
    ///
    /// This method does not panic.
    pub fn next(&mut self) -> &Snowflake {
        self.last_snowflake = self.last_snowflake.next();
        &self.last_snowflake
    }

    /// Get the current timestamp in seconds since the epoch (1970-01-01 00:00:00 UTC).
    ///
    /// # Returns
    /// The current timestamp in seconds
    pub fn get_timestamp() -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .expect("SystemTime before UNIX EPOCH!")
            .as_secs()
    }

    /// Wait for the next second and return the timestamp
    ///
    /// # Arguments
    /// * `current_timestamp` - The current timestamp in seconds
    ///
    /// # Returns
    /// The timestamp of the next second
    pub fn wait_next_timestamp(last_timestamp: u64) -> u64 {
        let mut timestamp = SnowflakeGenerator::get_timestamp();
        while timestamp <= last_timestamp {
            std::thread::sleep(std::time::Duration::from_millis(1));
            timestamp = SnowflakeGenerator::get_timestamp();
        }
        timestamp
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_new() {
        let generator = SnowflakeGenerator::new(420);
        assert_eq!(generator.last_snowflake, Snowflake::new(420));

        let generator = SnowflakeGenerator::new(69);
        assert_eq!(generator.last_snowflake, Snowflake::new(69));
    }

    #[test]
    fn test_start_at() {
        let snowflake = Snowflake::new(420);
        let generator = SnowflakeGenerator::start_at(&snowflake);
        assert_eq!(generator.last_snowflake, snowflake);
    }

    #[test]
    fn test_next() {
        let mut generator = SnowflakeGenerator::new(420);

        for _ in 0..10 {
            let snowflake = *generator.next();
            assert_eq!(snowflake, generator.last_snowflake);
        }
    }

    #[test]
    fn test_eq() {
        let gen1 = SnowflakeGenerator::new(420);
        let gen2 = SnowflakeGenerator::new(420);
        assert_eq!(gen1, gen2);

        let gen1 = Snowflake::new(420);
        let gen2 = Snowflake::new(69);
        assert_ne!(gen1, gen2);
    }

    #[test]
    fn test_snowflake_wait_next_timestamp() {
        let timestamp = SnowflakeGenerator::get_timestamp();

        let next = SnowflakeGenerator::wait_next_timestamp(timestamp);

        assert!(
            next > timestamp,
            "Snowflake.wait_next_timestamp didn't return a new timestamp"
        );
    }

    #[test]
    fn test_get_timestamp() {
        let timestamp = SnowflakeGenerator::get_timestamp();

        assert!(
            timestamp
                == std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
        );
    }
}
